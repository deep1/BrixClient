<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="Author" content="Leslie Bondaryk" />
	<meta name="Owner" content="Pearson" />
	<meta name="Copyright" content="Copyright (c) 2013 Pearson. All rights reserved." />
	<meta content="width=device-width, initial-scale=1.0" name="viewport" />
	<meta content="Carmen Santiago, Demo Book" name="description" />
	<title class="setTitle"></title>

    <!-- bootstrap_plus.css contains styling for the dropdown menu and other common core styles -->
    <link href="css/bootstrap_plus.css" rel="stylesheet" media="screen">
  	
  	<!-- widgets.css contains styling for the interactive brix -->
	<link href="css/widgets.css" rel="stylesheet">

	<!-- eCourse-master.css contains styling for all the navigation -->
	<link href="css/eCourse-master.css" rel="stylesheet" media="screen">

	<!-- content_styles.css contains styling for the narrative layout and responsive design -->
	<link href="css/content_styles.css" rel="stylesheet" media="screen">

</head>

<body>
<div class="container">
		<div class="span12 lc_ec_page">
			<section class="lc_ec_majorMinor lc_ec_pageInner">
       	 		<div class="lc_ec_content">
       	 			<h2 class="lc_ec_bHead"><span class='number setId'></span> 
											<span class="setTitle"></span>
					</h2>
		 			<div class="lc_ec_leading">
            			<p>Nuclear reactors use heat from fission reactions to turn water into steam, which spins turbines connected to generators that produce electricity. The figure shows a common design known as a pressurized water reactor.</p>
            			<div id="imgReactor"></div>
            		</div>
					<div id="steps" class"lc_ec_trailing"></div>
			</div>
		</section>
	</div>
</div>

    <script src="js/jquery-latest.js"></script>
	<script src="js/bootstrap.min.js"></script>
	<!-- <script src="js/jquery.touchSwipe.min.js"></script> -->
	<script src="js/jquery-ui-1.10.2.custom.js"></script>
	<script src="js/toc-structure.js"></script>    
	<script src="js/eCourse-master.js"></script>    
	<script src="js/d3.v3.min.js"></script>
    
	<script src="js/brixlib-compiled.js"></script>
	<!--
	<script src="../closure/closure-library/closure/goog/base.js"></script>
	<script src="../closure/closure-library/closure/goog/deps.js"></script>

	<script src="js/eventmanager.js"></script>
    <script src="js/widget-base.js"></script>
    <script src="js/widget-image.js"></script>
    <script src="js/widget-labelgroup.js"></script>
    <script src="js/widget-callouts.js"></script>
	-->

	<script>

	// Create an object that will contain the objects needed for the activities
	// on this page.
	pearson.brix.activity = {};
	var a = pearson.brix.activity;

	// The activity config that defines the brix and cement for this page
	a.config =
		{
			"sequenceNodeKey": "39b0706e-8587-447e-a598-ecc5e9a1b883",
			"containerConfig":
				[
					{
						"containerId": "imgReactor",
						"brixConfig":
							[
								{
									"bricId": "cimage1",
									"bricType": "CaptionedImage",
									"config":
										{
											"id": "cimg0n",
											"URI": "img/reactor.jpg",
											"caption": "Nuclear Reactor Schematic Diagram",
											"actualSize": {"height": 310, "width": 680},
											"captionPosition": "below"
										},
									"configFixup":
										{
											//<[optional] object describing runtime modifications to the config, perhaps
											//	adding properties referencing a previously created bric>
										}
								},
								{
									"bricId": "cntr1",
									"bricType": "SvgContainer",
									"config":
										{
											"node": d3.select("#imgReactor"),
											"maxSize": pearson.utils.Size.matchRatioWithHeight(350 - 40, {"height": 310, "width": 680}/*"cimage1"."config"."actualSize"*/),
										},
									"configFixup":
										{
											//<[optional] object describing runtime modifications to the config, perhaps
											//	adding properties referencing a previously created bric>
										}
								},
								{
									"bricId": "labels1",
									"bricType": "LabelGroup",
									"config":
										{
											"id": "reactorNum",
											"type": "numbered",
											"labels": 	
												[	
													{"content": "1", "xyPos": [0, 0.22], "width": 0},
													{"content": "2", "xyPos": [0.05, 0.43], "width": 0},
													{"content": "3", "xyPos": [0.3, 0.7], "width": 0},
													{"content": "4", "xyPos": [0.62, 0.65], "width": 0},
													{"content": "5", "xyPos": [0.66, 0.15], "width": 0}
												]
										},
									"configFixup":
										{
											//<[optional] object describing runtime modifications to the config, perhaps
											//	adding properties referencing a previously created bric>
										}
								}
							],
						"cementConfig":
							[
								{
									"cementId": "<unique id for this cement in this container>",
									"cementType": "BrixEventHandler",
									"config":
										{
											"events": ["fixup"],
											"action":
												{
													"type": "call-method",
													"bric": "labels1",
													"method": "lite",
													"params": ["liteKey"]
												}
										}
								}
							],
						"hookupActions":
							[
								{
									"actionType": "method-call", /* the method-call handles a lot of the actions needed, but I expect there are other types of actions */
									"config":
										{
											"objectId": "Invoker-GUID",
											"methodName": "registerObject",
											"args":
												[
													{ "type": "static", "value": "barChart_GUID" }, /* static args use the value specified here */
													{ "type": "bric-obj-ref", "id": "barChart_GUID" } /* obj refs are replaced w/ the object created above w/ the specified id */
												]
										}
								}
							]
					},
					{
						"containerId": "steps",
						"brixConfig":
							[
								{
									"bricId": "lbltbl1",
									"bricType": "Callouts",
									"config":
										{
										},
									"configFixup":
										{
											//<[optional] object describing runtime modifications to the config, perhaps
											//	adding properties referencing a previously created bric>
										}
								},
							],
						"cementConfig":
							[
								{
									"cementId": "<unique id for this cement in this container>",
									"cementType": "BrixEventHandler",
									"config":
										{
											//... config for cement type specified
										}
								}
							],
						"hookupActions":
							[
								{
									"actionType": "method-call", /* the method-call handles a lot of the actions needed, but I expect there are other types of actions */
									"config":
										{
											"objectId": "Invoker-GUID",
											"methodName": "registerObject",
											"args":
												[
													{ "type": "static", "value": "barChart_GUID" }, /* static args use the value specified here */
													{ "type": "bric-obj-ref", "id": "barChart_GUID" } /* obj refs are replaced w/ the object created above w/ the specified id */
												]
										}
								}
							]
					}
				]
		};

	// create the eventmanager to be used by the created brix, and the
	// bricLayer which will create them, and then tell the bricLayer to build.
	a.eventManager = new pearson.utils.EventManager();
	a.bricLayer = new pearson.brix.BricLayer(null, a.eventManager);

	a.building = a.bricLayer.build(a.config);

	// EVERYTHING FROM HERE ON will be removed once the config and bricLayer.build
	// are working. -mjl

	// local aliases for convenience
	var eventManager = a.eventManager;
	var Size = pearson.utils.Size;
	var SVGContainer = pearson.brix.SVGContainer;
	var CaptionedImage = pearson.brix.CaptionedImage;
	var LabelGroup = pearson.brix.LabelGroup;
	var Callouts = pearson.brix.Callouts;
	
	var cimgConfig =
		{
			id: "cimg0n",
			URI: 'img/reactor.jpg',
			caption: "Nuclear Reactor Schematic Diagram",
			actualSize: {height: 310, width: 680},
			captionPosition: "below"
		};
	
	var cntrSize = Size.matchRatioWithHeight(350 - 40, cimgConfig.actualSize);

	var cntrConfig0 = 
		{
			node: d3.select("#imgReactor"),
			maxSize: cntrSize,
			maxWid: cntrSize.width, //550,
			maxHt: 350
		};
		
	var cntr0 = new SVGContainer(cntrConfig0);
	
	var cimg0 = new CaptionedImage(cimgConfig, eventManager);
	
	cntr0.append(cimg0, {topPercentOffset: 0, leftPercentOffset: 0, heightPercent: 1, widthPercent: 1});
	
	//put numbered highlightable bullets on the image
	var numLabels = new LabelGroup(
		{
			id: "reactorNum",
			type: "numbered",
			labels: 	
			[	
				{content: "1", xyPos: [0, 0.22], width: 0},
				{content: "2", xyPos: [0.05, 0.43], width: 0},
				{content: "3", xyPos: [0.3, 0.7], width: 0},
				{content: "4", xyPos: [0.62, 0.65], width: 0},
				{content: "5", xyPos: [0.66, 0.15], width: 0}
			]
		}, eventManager);
	
	cimg0.append(numLabels);

	// Create the callout array, which also emits events so you 
	//can click on the table row to highlight the labels.  
	var callEm = new Callouts({
		id: "callme",
		show: "all",
		type: "numbered",
		headers: ["Nuclear Reactor function" ],
		textBits: [
		{cols: ["In a closed circuit, (green) water is pumped at high pressure to the reactor core."]},
		{cols:[ "Heat is generated by fission in the fuel rods in the reactor core, which heats the circulating water. Thick layers of concrete and steel or lead contain the reactor coreâ€™s radioactivity."]},
		{cols:[ "In the steam generator, the energy from the heated water is used to boil water from a separate supply. The resulting steam moves through a pipe to a turbine."]},
		{cols:["The steam turns the turbine, which is connected to an electricity generator. Power lines distribute the electricity. A typical reactor produces as much as a coal-fired power plant."]},
		{cols:[ "A third supply of water is used to cool the steam so it condenses into water, which is pumped back to the steam generator."]}
		]
	},eventManager);
	
	callEm.draw(d3.select("#steps"));
	
 

	// Modify the value of the data for the bar graph when the
	//numerical input changes.  So, subscribe to the event emitted by inputLevo,
	//or inputDextro,
	//and target whatever is identified by the handler in the second argument.
	//TODO: make these methods of the target widget?

	// Handle changes of the levo and dextro input values
	eventManager.subscribe(numLabels.selectedEventId,
						   handleSelectionChanged);
	eventManager.subscribe(callEm.selectedEventId,
						   handleSelectionChanged);

 
//TEST: set the start highlight state of 0 index by calling the 
//handler with a hard-set index of 0.  This should result in the
//first label getting highlighted and the first callout being displayed.
	handleSelectionChanged({selectKey: '0'});
/************************************************************************
* handleSelectionChanged                                            *//**
*
* handleInputValueChanged is called from the event handler for one of
* the input widgets when the user changes its value. It updates the
* given matching input widget's value to match the new value and then
* updates the bar chart.
*
* @param eventDetails			These are the keyed values returned by 
*								the event, in this case, a selection
*								(click).
*************************************************************************/
	function handleSelectionChanged(eventDetails)
	{
		//Handler needs to get written into each page, 
		//each widget will have it's own way of responding  
		//LabelLite should be a method of Labels, once Labels
		//is written as a constructor
		numLabels.lite(eventDetails.selectKey);
		callEm.lite(eventDetails.selectKey);
		
	}
	

	
	</script>
</body>
</html>
