{
	/* 
		ActivityConfig JSON for the Kanrorowski.

		Based on Mikes initial draft.

		Within the comments there are topics surrounded by double brackets.
		Those are topic related to that comment
	*/
"activityId": "PAF-activity-GUID",
"containerConfig":
	[
		{ 
			"containerId": "LEVO-DIV-ID",
			"brixConfig":
				[
					{
						"bricId": "levo_GUID",
						"bricType": "Slider",
						"config":
							{
								"startVal": 35,
								"minVal": 0,
								"maxVal": 100,
								"stepVal": 1,
								"unit": "%",
								"label": "Levorotary",
								"format": ".0f" /* Formatting using fprintf style (at runtime means d3.format('.0f')) */
							},
						"configFixup":
						{
							/* Start value is 100 - dextro.startVal (but dextro may be in different iframe) 
							   [[STATE CACHE]]  [[INIT SEQUENCE]]
							*/
						}
					}
				]
			"cementConfig":
				[
					/* Mike's Invoker, so the levo slide gets changed by dextro's update */ 
					{
						"cementId": "Invoker-GUID",
						"config":
							{
								"topic": "invoke", /* by default the topic will be 'invoke' */
								"references": ["levo_GUID"] /*object(s) registered to the Invoker */
							}
					}
				]
		}, 
		{
			"containerId": "DEXTRO-DIV-ID",
			"brixConfig":
				[
					{
						"bricId": "dextro_GUID",
						"bricType": "Slider",
						"config":
							{
								"startVal": 65,
								"minVal": 0,
								"maxVal": 100,
								"stepVal": 1,
								"unit": "%",
								"label": "Dextrorotary",
								"format": ".0f" /* Formatting using fprintf style (at runtime means d3.format('.0f')) */
							},
						"configFixup":
						{
							/* Start value is 100 - levo.startVal (but levo may be in different iframe) 
							   How do we guarantee this invariant?
							   Whoever is initialized later will be defined by the bric that was initialized first (?).
							   
							   [[STATE CACHE]] 
							*/
						}
					}
				]
			"cementConfig":
				[
					/* Mike's Invoker, so the dextro slide gets changed by levo's update */ 
					{
						"cementId": "Invoker-GUID",
						"config":
							{
								"references": ["dextro_GUID"] /* objects registered to the Invoker */
							}
					}
				]
		}, 
		{
			"containerId": "BARCHART-DIV-ID",
			"brixConfig":
				[
					{
						"bricId": "barMarks_GUID",
						"bricType": "MarkerGroup",
						"config":
							{
								"marks":  65
							},
					},
					{
						"bricId": "barChart_GUID",
						"bricType": "BarChart",
						"config":
							{
								/* Since dextro & levo are not in same iframe, we cannot use direct reference to set Data attribute.
								   Shall we use some kind of data store (cache) for external references? [[DATA CACHE]]
								   Or since this is a initialization data, we can have a separate init procedure which is called later
								   when all brics were instantiated. But then how we handle chain initialization. 
								   E.g. (a) depend on (b) that depends on (c) and so on?
								   How about cases of cyclical dependency: some fields in (a) depend on some fields in (b) and vice versa.
								   [[ INITIALIZATION FLOW ]]  

     							   If we use a cement as data caching mechanism, that cement must be initialized prior to the brics (?)

								 */
								"data": [$dextroData, $levoData],  /* Notice that for illustrative purpose, an expression was used where $ means variable.  Of course this will not work. */
								"xAxisFormat": { type: "linear",
											   ticks: [0,10,20,30,40,50,60,70,80,90,100],
											   orientation: "bottom",
											   label: "% enantiomers" },
								"yAxisFormat": { type: "ordinal",
											   orientation: "left",
											    }
							},
						"configFixup":
						{
							"append": "barMarks_GUID" /* translation of: Bars.append(barMarks) */
						}
					},
					{
						"bricId": "barContainer_GUID",
						"bricType": "SVGContainer",
						"config":
							{
								/* In the authoring mode, a DIV of this id was already generated by Authoring tool
								   in the iframe.
								   [[ IFRAME-TO-DIV TRANSLATION ]]
								 */
								node: "#barChart", 
								maxWid: 450,
								maxHt: 400
							},
						"configFixup":
						{
							"append":
								{
									"objectId": "barChart_GUID", 
									topPercentOffset: 0.2, 
									leftPercentOffset: 0, 
									heightPercent: 0.8, 
									widthPercent: 1
								}
						}
					},
				]
			"cementConfig":
				[
					/* Just in case barchart object is invoked. */ 
					{
						"cementId": "Invoker-GUID",
						"config":
							{
								"references": "barChart_GUID" /*objects registered to the Invoker */
							}
					},
					{
						"cementId": "handleLevoInputValueChanged-GUID",
						"cementType": "BrixEventHandler",
						"config":
							{
								"topic": "levo_valueChanged",
								/* This part is a hard problem to solve:
								   How to represent in JSON the handler's logic? (i.e. avoiding using eval() ) 
								   BTW, JSON does not seem to support multi-line strings 

								   The "logic" below assumes the use of eval() until better (safer) solution comes around.
								   Notice that the bricStates are local store caching states of other brics. 
								   Maybe a cement will abstract the external bric state accessing. But then, that cement must be initialized prior to this bric. [[INIT FLOW]]
								   Also notice that the publish topic is also hard coded, which should not be.
								   
								   [[HARD PROBLEM]] [[CEMENT]]
								   FYI: My prior research at grad school was related to Task Management, and 
								   Task Description Language was one of the challenges we faced.
								   Handler Cement is similar to Task Description in that it has to express
								   the logic is a clear and save manner. 
								   Using expression language such as XPath was a partial solution.
								   */
								"logic": "
									bricsStates.levo = newValue;
									bricsStates.dextro = 100 - newValue;

									eventManager.publish('invoke, {target: 'dextro-GUID', method: 'setValue', args: bricsStates.dextro });

									var diff = bricsStates.dextro - bricsStates.levo,
									    absDiff = Math.abs(diff);
								"
							}
					},
					
					{
						/* This sample uses BrixInputChangeEventHandler, which is an alternative of the 
						   generic BrixEventHandler above. 
						   The idea is that instead of providing a generic "empty logic" handler, the
						   BrixInputChangeEventHandler is more specific and focuses on handling some input
						   field change events. Provides a pattern of: listening to a topic and when the value
						   has changed invoke a specific object's method passing argument set through 
						   expression language.
						   [[CEMENT]]
						*/
						"cementId": "alternative-handleLevoInputValueChanged-GUID",
						"cementType": "BrixInputChangeEventHandler", /* the InputChangeEventHandler is specialization of BrixEventHandler*/
						"config":
							{
								topic: "levo_valueChanged",
								fieldName: "newValue", /* this is the name of the field in the event (e.g.: ed.newValue) which the handler is interested in */
								onChange: 
									{
										invoke: "dextro-GUID.setValue"
										argument: "100 - $newValue" /* need to use some kind of expression language as XPath (a la BPEL) or (http://www.jsoniq.org/) */
									}
							}
					},
					{
						"cementId": "updateBarChartHandler-GUID",
						/* In the original Kantorski demo code, the function updateBarChart() was called by levo and dextroInputValueChanged handlers 
						   This was a way of reusing same logic for both cases.
						   Would it be good idea to have a "AuxiliaryFunctionCement" that allows
						   arbitrary logic?
						   If so, how are we going to allow "arbitrary" logic?
						   How are we going to obtain states(properties) of other brics? (E.g. levoData, dextroData) 
						   [[CEMENT]]
						*/

						"cementType": "BrixEventHandler", 
						"config":
							{
								topics: ["levo_valueChanged", "dextro_valueChanged"] /* both topics triggers update to the bar chart */

								/* Below we are assuming eval() for the mean time */
								logic: "
									levoData[0].x = bricsStates.levo; 
									dextroData[0].x = bricsStates.dextro;
									
									Bars.Data = [dextroData,levoData]
									
									var newMark = [(levoData[0].x > dextroData[0].x) ? dextroData[0] : levoData[0]];
									barMarks.marks = newMark;
									console.log("marks", barMarks.marks)
									Bars.redraw();
								"
							}
					},
				]
		}, 
		{
			"containerId": "EEREADOUT-DIV-ID",
			"brixConfig":
				[
					{
						"bricId": "eeReadout_GUID",
						"bricType": "Readout",
						"config":
							{
								"node": "#ee",
						        "id": 'eeRead',
								"startVal": 20,  /*absDiff*/
								"readOnly": true,
								"size": 4,
								"unit": "%", 
								"label": "ee ="
							},
						"configFixup":
						{
							
						}
					}
				]
		}, 
		{
			"containerId": "SLIDER1-DIV-ID",
			"brixConfig":
				[
					{
						"bricId": "sl1_GUID",
						"bricType": "Slider",
						"config":
							{
								"id": "slider1",
								"startVal": 80,
								"minVal": 0,
								"maxVal": 360,
								"stepVal": 10,
								"unit": "&deg;",
								"label": "Specific rotation (&alpha;): ",
								"format": '.0f'
							},
						"configFixup":
						{
							
						}
					}
				]
		}, 
		{
			"containerId": "PIECHART-DIV-ID",
			/* This config is based on old version. 
			   Probably the structure will differ, so I will not put further effort here.
			 */
			"brixConfig":
				[
					{
						"bricId": "pieDish",
						"bricType": "PieChart",
						"config":
							{
								node: "#roto",
								maxWid: 200,
								maxHt: 200,
								"axes":
									{
										xPosPerc: 0, yPosPerc:0,
										xPerc: 1, yPerc: 1,
										xaxisType: "linear",  yaxisType: "linear",
										xTicks: 0, yTicks: 0,
										xOrient: "top", yOrient: "right",
										xLabel: "Rotation (&deg;)"
									},
								"pie":
									{
										Data: [{x:80 * diff/360}], /* [[STATE CACHING]] diff = dextro-levo */
										xYPos: [.5,.5]
									}
							},
						"configFixup":
						{
							
						}
					},

				],
			"cementConfig":
				[
					{
						"cementId": "updatePieChartHandler-GUID",
						"config":
							{
								"topics": ["levo_valueChanged", "dextro_valueChanged"] /* both topics triggers update to the bar chart */
								/* Again, for the mean time, assuming eval() */
								logic: "
								pieDish.Pie({
									Data: [{x: sl1.getValue() * diff/360}],
									xYPos: [0.5,0.5]
									});
								var newMark = {x:(1/2), label: d3.format("+0r2")(sl1.getValue() * diff/100) + "&deg;"};
								pieDish.LineMarkers( {
									xMarks: [newMark]
									});
								"
							}
					},
				]
		}
		
	]
}
